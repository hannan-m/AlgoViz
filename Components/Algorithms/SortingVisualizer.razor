@page "/sorting"
@implements IDisposable
@rendermode InteractiveServer

<div class="min-h-screen bg-white p-4">
    <h1 class="text-3xl font-bold mb-4 text-center text-gray-800" id="page-title">Sorting Algorithm Visualizer</h1>
    <p class="text-center mb-6 text-gray-600">An interactive tool to learn and understand sorting algorithms</p>

    <div class="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-4 gap-6">
        <!-- Controls Panel -->
        <div class="lg:col-span-1 bg-gray-50 border border-gray-200 rounded-lg p-4 shadow-sm">
            <h2 class="text-xl font-bold mb-4 text-gray-700">Controls</h2>
            
            <!-- Algorithm Selection -->
            <fieldset class="mb-5">
                <legend class="text-sm font-medium text-gray-700 mb-2">Select Algorithm</legend>
                <div class="space-y-2">
                    @foreach (var algo in algorithms)
                    {
                        <div class="flex items-center">
                            <input type="radio" id="algo-@algo.Key" name="algorithm" 
                                class="w-4 h-4 text-blue-600 focus:ring-blue-500"
                                checked="@(selectedAlgorithm == algo.Key)"
                                @onchange="@(e => selectedAlgorithm = algo.Key)" />
                            <label for="algo-@algo.Key" class="ml-2 block text-gray-700">
                                @algo.Value.Name
                            </label>
                        </div>
                    }
                </div>
            </fieldset>
            
            <!-- Array Size -->
            <div class="mb-5">
                <label for="array-size" class="block text-sm font-medium text-gray-700 mb-2">
                    Array Size: @arraySize elements
                </label>
                <input type="range" id="array-size" min="5" max="40" step="5" 
                    aria-valuemin="5" aria-valuemax="40" aria-valuenow="@arraySize"
                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    value="@arraySize" @onchange="@(e => SetArraySize(int.Parse(e.Value.ToString())))" />
                <div class="flex justify-between text-xs text-gray-600 mt-1">
                    <span>5</span>
                    <span>20</span>
                    <span>40</span>
                </div>
            </div>
            
            <!-- Animation Speed -->
            <div class="mb-5">
                <label for="speed-slider" class="block text-sm font-medium text-gray-700 mb-2">
                    Animation Speed: @speed%
                </label>
                <input type="range" id="speed-slider" min="10" max="100" step="10" 
                    aria-valuemin="10" aria-valuemax="100" aria-valuenow="@speed"
                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    value="@speed" @onchange="@(e => speed = int.Parse(e.Value.ToString()))" />
                <div class="flex justify-between text-xs text-gray-600 mt-1">
                    <span>Slow</span>
                    <span>Medium</span>
                    <span>Fast</span>
                </div>
            </div>
            
            <!-- Array Type -->
            <div class="mb-5">
                <label class="block text-sm font-medium text-gray-700 mb-2">Array Type</label>
                <div class="grid grid-cols-2 gap-2">
                    <button type="button" @onclick="() => GenerateRandomArray()" disabled="@isSorting"
                            class="@GetArrayTypeButtonClass("random")"
                            aria-pressed="@(currentArrayType == "random")"
                            aria-disabled="@isSorting">
                        <span class="flex items-center justify-center">Random</span>
                    </button>
                    <button type="button" @onclick="() => GenerateNearlySortedArray()" disabled="@isSorting"
                            class="@GetArrayTypeButtonClass("nearlySorted")"
                            aria-pressed="@(currentArrayType == "nearlySorted")"
                            aria-disabled="@isSorting">
                        <span class="flex items-center justify-center">Nearly Sorted</span>
                    </button>
                    <button type="button" @onclick="() => GenerateReversedArray()" disabled="@isSorting"
                            class="@GetArrayTypeButtonClass("reversed")"
                            aria-pressed="@(currentArrayType == "reversed")"
                            aria-disabled="@isSorting">
                        <span class="flex items-center justify-center">Reversed</span>
                    </button>
                    <button type="button" @onclick="() => GenerateFewUniquesArray()" disabled="@isSorting"
                            class="@GetArrayTypeButtonClass("fewUniques")"
                            aria-pressed="@(currentArrayType == "fewUniques")"
                            aria-disabled="@isSorting">
                        <span class="flex items-center justify-center">Few Uniques</span>
                    </button>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="mt-6 space-y-3">
                @if (!isSorting && !isStepMode)
                {
                    <button type="button" @onclick="StartSort"
                            class="w-full px-4 py-2 bg-blue-600 text-white font-medium rounded-md 
                                   hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                        <span class="flex items-center justify-center">Start Auto-Sort</span>
                    </button>
                    
                    <button type="button" @onclick="EnableStepMode"
                            class="w-full px-4 py-2 bg-green-600 text-white font-medium rounded-md 
                                   hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        <span class="flex items-center justify-center">Step-by-Step Mode</span>
                    </button>
                }
                else if (isStepMode)
                {
                    <div class="grid grid-cols-2 gap-2">
                        <button type="button" @onclick="StepForward"
                                class="px-4 py-2 bg-green-600 text-white font-medium rounded-md 
                                       hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                            <span class="flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd" />
                                </svg>
                                Next Step
                            </span>
                        </button>
                        <button type="button" @onclick="DisableStepMode"
                                class="px-4 py-2 bg-gray-600 text-white font-medium rounded-md 
                                       hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                            <span class="flex items-center justify-center">Exit Step Mode</span>
                        </button>
                    </div>
                }
                else if (isSorting)
                {
                    <button type="button" @onclick="StopSort"
                            class="w-full px-4 py-2 bg-red-600 text-white font-medium rounded-md 
                                   hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                        <span class="flex items-center justify-center">Stop Sorting</span>
                    </button>
                }
                
                <button type="button" @onclick="ResetArray" disabled="@isSorting"
                        class="w-full px-4 py-2 bg-gray-200 text-gray-800 font-medium rounded-md 
                               hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 
                               disabled:opacity-50 disabled:cursor-not-allowed"
                        aria-disabled="@isSorting">
                    <span class="flex items-center justify-center">Reset Array</span>
                </button>
            </div>
        </div>
        
        <!-- Visualization Area -->
        <div class="lg:col-span-3 flex flex-col h-full">
            <!-- Status Bar -->
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 mb-4 shadow-sm" 
                 aria-live="polite" role="status">
                <div class="flex flex-wrap justify-between items-center">
                    <div class="flex items-center">
                        @if (isSorting)
                        {
                            <div class="relative h-4 w-4 mr-2">
                                <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                                <span class="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                            </div>
                            <span class="font-semibold text-gray-700">@algorithms[selectedAlgorithm].Name in progress...</span>
                        }
                        else if (isStepMode)
                        {
                            <div class="h-4 w-4 mr-2 bg-green-500"></div>
                            <span class="font-semibold text-gray-700">Step-by-Step: @algorithms[selectedAlgorithm].Name</span>
                        }
                        else if (isSortingCompleted)
                        {
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                            </svg>
                            <span class="font-semibold text-gray-700">Sorting completed!</span>
                        }
                        else
                        {
                            <span class="font-semibold text-gray-700">Ready to sort</span>
                        }
                    </div>
                    
                    <div class="flex space-x-4 text-sm">
                        <div class="flex items-center">
                            <span class="font-medium text-gray-600">Comparisons:</span>
                            <span class="text-gray-800 ml-1">@comparisonCount</span>
                        </div>
                        <div class="flex items-center">
                            <span class="font-medium text-gray-600">Swaps:</span>
                            <span class="text-gray-800 ml-1">@swapCount</span>
                        </div>
                        @if (isSorting || isSortingCompleted || isStepMode)
                        {
                            <div class="flex items-center">
                                <span class="font-medium text-gray-600">Time:</span>
                                <span class="text-gray-800 ml-1">@stopwatch.ElapsedMilliseconds ms</span>
                            </div>
                        }
                    </div>
                </div>
            </div>
            
            <!-- Main Visualization -->
            <div class="border border-gray-200 rounded-lg p-4 shadow-sm bg-white flex-grow flex flex-col">
                <!-- Current operation explanation -->
                @if (isStepMode && currentStepExplanation != null)
                {
                    <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                        <h3 class="font-medium text-blue-700 mb-1">Current Operation:</h3>
                        <p class="text-blue-800">@currentStepExplanation</p>
                    </div>
                }
                
                <!-- Bar Visualization -->
                <div class="border-2 border-gray-300 rounded bg-gray-50 p-4 h-80">
                    <!-- Fixed-height container to ensure consistent visualization -->
                    <div class="relative h-full w-full">
                        <div class="flex h-full items-end">
                            @for (int i = 0; i < array.Length; i++)
                            {
                                var heightPercent = (array[i] * 90 / maxValue);
                                var barColor = GetBarColor(i);
                                var margin = array.Length <= 20 ? 2 : 1;
                                
                                <div class="mx-@margin h-full flex-grow flex flex-col items-center justify-end">
                                    <!-- The bar -->
                                    <div class="@barColor w-full rounded-t-sm border border-gray-300" 
                                         style="height: @(Math.Max(2, heightPercent))%;">
                                        @if (array.Length <= 15)
                                        {
                                            <div class="text-center text-xs font-bold text-white">
                                                @array[i]
                                            </div>
                                        }
                                    </div>
                                    
                                    <!-- Index number -->
                                    @if (array.Length <= 30)
                                    {
                                        <div class="text-xs text-gray-600 mt-1">@i</div>
                                    }
                                </div>
                            }
                        </div>
                        
                        <!-- Pointers for current comparisons -->
                        <div class="absolute top-0 left-0 right-0">
                            @for (int i = 0; i < array.Length; i++)
                            {
                                if (i == comparison1 || i == comparison2 || i == pivot)
                                {
                                    var leftPosition = (i + 0.5) * (100.0 / array.Length);
                                    var label = i == pivot ? "pivot" : (i == comparison1 ? "i" : "j");
                                    var bgColor = i == pivot ? "bg-yellow-200" : "bg-red-200";
                                    var textColor = i == pivot ? "text-yellow-700" : "text-red-700";
                                    var lineColor = i == pivot ? "bg-yellow-500" : "bg-red-500";
                                    
                                    <div class="absolute transform -translate-x-1/2" style="left: @(leftPosition)%;">
                                        <div class="flex flex-col items-center">
                                            <div class="@bgColor @textColor text-xs font-bold px-1 py-0.5 rounded">
                                                @label
                                            </div>
                                            <div class="h-4 w-0.5 @lineColor"></div>
                                        </div>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>
                
                <!-- Code Explanation and Legend -->
                <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Algorithm Pseudocode -->
                    <div class="p-3 border border-gray-200 rounded-md bg-gray-50">
                        <h3 class="font-medium text-gray-700 mb-2">@algorithms[selectedAlgorithm].Name Pseudocode</h3>
                        <div class="relative overflow-auto h-32">
                            <pre class="text-xs text-gray-700 font-mono">@algorithms[selectedAlgorithm].Pseudocode</pre>
                            @if (isStepMode && currentPseudocodeLine > 0)
                            {
                                <div class="absolute left-0 bg-yellow-200 opacity-40" 
                                     style="width: 100%; height: 1.25rem; top: @((currentPseudocodeLine - 1) * 1.25)rem">
                                </div>
                            }
                        </div>
                    </div>
                    
                    <!-- Legend and Info -->
                    <div class="p-3 border border-gray-200 rounded-md bg-gray-50">
                        <h3 class="font-medium text-gray-700 mb-2">Legend</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="flex items-center">
                                <div class="w-4 h-4 bg-blue-500 mr-2"></div>
                                <span class="text-sm">Unsorted</span>
                            </div>
                            <div class="flex items-center">
                                <div class="w-4 h-4 bg-red-500 mr-2"></div>
                                <span class="text-sm">Comparing</span>
                            </div>
                            <div class="flex items-center">
                                <div class="w-4 h-4 bg-yellow-500 mr-2"></div>
                                <span class="text-sm">Pivot Element</span>
                            </div>
                            <div class="flex items-center">
                                <div class="w-4 h-4 bg-green-500 mr-2"></div>
                                <span class="text-sm">Sorted</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Algorithm Information -->
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 mt-4 shadow-sm">
                <h2 class="text-xl font-bold mb-2 text-gray-700">@algorithms[selectedAlgorithm].Name</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-3">
                    <div>
                        <h3 class="text-sm font-medium text-gray-500">Time Complexity</h3>
                        <div class="mt-1 text-sm">
                            <div><span class="font-medium">Best:</span> <span class="text-green-600">@algorithms[selectedAlgorithm].BestTime</span></div>
                            <div><span class="font-medium">Average:</span> <span class="text-blue-600">@algorithms[selectedAlgorithm].AvgTime</span></div>
                            <div><span class="font-medium">Worst:</span> <span class="text-red-600">@algorithms[selectedAlgorithm].WorstTime</span></div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-sm font-medium text-gray-500">Space Complexity</h3>
                        <div class="mt-1 text-sm font-medium text-gray-800">@algorithms[selectedAlgorithm].Space</div>
                    </div>
                    
                    <div>
                        <h3 class="text-sm font-medium text-gray-500">Stability</h3>
                        <div class="mt-1 text-sm font-medium @(algorithms[selectedAlgorithm].IsStable ? "text-green-600" : "text-red-600")">
                            @(algorithms[selectedAlgorithm].IsStable ? "Stable" : "Unstable")
                        </div>
                    </div>
                </div>
                
                <div class="border-t border-gray-200 pt-3">
                    <h3 class="text-sm font-medium text-gray-500 mb-1">How It Works</h3>
                    <p class="text-sm text-gray-700">@algorithms[selectedAlgorithm].Description</p>
                </div>
                
                @if (isSortingCompleted)
                {
                    <div class="mt-4 pt-3 border-t border-gray-200">
                        <h3 class="text-sm font-medium text-gray-500 mb-2">Performance Summary</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                            <div>
                                <div class="font-medium">Total operations: <span class="text-blue-600">@(comparisonCount + swapCount)</span></div>
                                <div class="font-medium">Operations per element: <span class="text-blue-600">@(((double)(comparisonCount + swapCount) / array.Length).ToString("F2"))</span></div>
                                <div class="font-medium">Time elapsed: <span class="text-blue-600">@stopwatch.ElapsedMilliseconds ms</span></div>
                            </div>
                            <div>
                                <div class="font-medium">Comparisons: <span class="text-blue-600">@comparisonCount</span> (@(((double)comparisonCount / Math.Max(1, comparisonCount + swapCount) * 100).ToString("F0"))%)</div>
                                <div class="font-medium">Swaps: <span class="text-blue-600">@swapCount</span> (@(((double)swapCount / Math.Max(1, comparisonCount + swapCount) * 100).ToString("F0"))%)</div>
                                <div class="font-medium">Efficiency rating: <span class="@GetEfficiencyColor()">@GetEfficiencyRating()</span></div>
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    // Core array and visualization state
    private int[] array = Array.Empty<int>();
    private bool isSorting = false;
    private bool isSortingCompleted = false;
    private int? comparison1;
    private int? comparison2;
    private int? pivot;
    private int maxValue = 100;
    private int speed = 50;
    private int arraySize = 20;
    private HashSet<int> sortedIndices = new();
    private int comparisonCount = 0;
    private int swapCount = 0;
    private string currentArrayType = "random";
    
    // Step-by-step mode
    private bool isStepMode = false;
    private Queue<Action> stepActions = new();
    private string? currentStepExplanation = null;
    private int currentPseudocodeLine = 0;
    
    // Performance tracking
    private System.Diagnostics.Stopwatch stopwatch = new();
    private int updateCounter = 0;
    private CancellationTokenSource? cts;
    
    // Algorithm information dictionary
    private Dictionary<string, AlgorithmInfo> algorithms = new Dictionary<string, AlgorithmInfo>
    {
        { "bubble", new AlgorithmInfo {
            Name = "Bubble Sort",
            BestTime = "O(n)",
            AvgTime = "O(n²)",
            WorstTime = "O(n²)",
            Space = "O(1)",
            IsStable = true,
            Description = "Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.",
            Pseudocode = 
@"procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n-1 do
            if A[i-1] > A[i] then
                swap(A[i-1], A[i])
                swapped := true
            end if
        end for
        n := n - 1
    until not swapped
end procedure"
        }},
        { "insertion", new AlgorithmInfo {
            Name = "Insertion Sort",
            BestTime = "O(n)",
            AvgTime = "O(n²)",
            WorstTime = "O(n²)",
            Space = "O(1)",
            IsStable = true,
            Description = "Builds the sorted array one item at a time by taking each element from the unsorted part and inserting it into its correct position in the sorted part.",
            Pseudocode = 
@"procedure insertionSort(A : list of sortable items)
    n := length(A)
    for i := 1 to n-1 do
        j := i
        while j > 0 and A[j-1] > A[j] do
            swap(A[j], A[j-1])
            j := j - 1
        end while
    end for
end procedure"
        }},
        { "selection", new AlgorithmInfo {
            Name = "Selection Sort",
            BestTime = "O(n²)",
            AvgTime = "O(n²)",
            WorstTime = "O(n²)",
            Space = "O(1)",
            IsStable = false,
            Description = "Repeatedly selects the smallest (or largest) element from the unsorted portion of the list and moves it to the sorted portion of the list.",
            Pseudocode = 
@"procedure selectionSort(A : list of sortable items)
    n := length(A)
    for i := 0 to n-2 do
        minIndex := i
        for j := i+1 to n-1 do
            if A[j] < A[minIndex] then
                minIndex := j
            end if
        end for
        if minIndex != i then
            swap(A[i], A[minIndex])
        end if
    end for
end procedure"
        }},
        { "quick", new AlgorithmInfo {
            Name = "Quick Sort",
            BestTime = "O(n log n)",
            AvgTime = "O(n log n)",
            WorstTime = "O(n²)",
            Space = "O(log n)",
            IsStable = false,
            Description = "Selects a 'pivot' element and partitions the array around the pivot, placing smaller elements to the left and larger elements to the right. It then recursively sorts the sub-arrays.",
            Pseudocode = 
@"procedure quickSort(A, lo, hi)
    if lo < hi then
        p := partition(A, lo, hi)
        quickSort(A, lo, p - 1)
        quickSort(A, p + 1, hi)
    end if
end procedure

procedure partition(A, lo, hi)
    pivot := A[hi]
    i := lo - 1
    for j := lo to hi - 1 do
        if A[j] <= pivot then
            i := i + 1
            swap A[i] with A[j]
        end if
    end for
    swap A[i + 1] with A[hi]
    return i + 1
end procedure"
        }},
        { "merge", new AlgorithmInfo {
            Name = "Merge Sort",
            BestTime = "O(n log n)",
            AvgTime = "O(n log n)",
            WorstTime = "O(n log n)",
            Space = "O(n)",
            IsStable = true,
            Description = "Divides the array into two halves, recursively sorts them, and then merges the sorted halves. It's based on the divide-and-conquer paradigm.",
            Pseudocode = 
@"procedure mergeSort(A, lo, hi)
    if lo < hi then
        mid := floor((lo + hi) / 2)
        mergeSort(A, lo, mid)
        mergeSort(A, mid + 1, hi)
        merge(A, lo, mid, hi)
    end if
end procedure

procedure merge(A, lo, mid, hi)
    Create temporary arrays L and R
    Copy A[lo..mid] to L and A[mid+1..hi] to R
    i := 0, j := 0, k := lo
    while i < length(L) and j < length(R) do
        if L[i] <= R[j] then
            A[k] := L[i]
            i := i + 1
        else
            A[k] := R[j]
            j := j + 1
        end if
        k := k + 1
    end while
    
    Copy remaining elements from L or R back into A
end procedure"
        }}
    };
    
    private string selectedAlgorithm = "bubble";

    protected override void OnInitialized()
    {
        GenerateRandomArray();
    }
    
    // Helper for array type button styling
    private string GetArrayTypeButtonClass(string arrayType)
    {
        string baseClass = "py-2 px-3 text-sm rounded-md transition-all focus:outline-none focus:ring-2 focus:ring-offset-1";
        
        if (isSorting || isStepMode)
        {
            return $"{baseClass} bg-gray-100 text-gray-400 cursor-not-allowed";
        }
        
        if (currentArrayType == arrayType)
        {
            return $"{baseClass} bg-blue-100 text-blue-700 border border-blue-300";
        }
        
        return $"{baseClass} bg-gray-100 text-gray-700 hover:bg-gray-200 border border-gray-300";
    }
    
    // Helper for bar coloring
    private string GetBarColor(int index)
    {
        if (index == comparison1 || index == comparison2)
            return "bg-red-500";
        else if (index == pivot)
            return "bg-yellow-500";
        else if (sortedIndices.Contains(index))
            return "bg-green-500";
        else
            return "bg-blue-500";
    }
    
    // Set array size with validation
    private void SetArraySize(int newSize)
    {
        if (isSorting || isStepMode) return;
        
        // Store current type before changing size
        var previousType = currentArrayType;
        
        // Update the size
        arraySize = newSize;
        
        // Reset visualization state
        ResetSortingState();
        
        // Create new array with selected type
        switch (previousType)
        {
            case "random":
                CreateRandomArray();
                break;
            case "nearlySorted":
                CreateNearlySortedArray();
                break;
            case "reversed":
                CreateReversedArray();
                break;
            case "fewUniques":
                CreateFewUniquesArray();
                break;
            default:
                CreateRandomArray();
                break;
        }
        
        // Force UI update
        StateHasChanged();
    }
    
    // Simple array creation methods - no validation or state handling
    private void CreateRandomArray()
    {
        var random = new Random();
        
        // Create new array with exact size
        array = new int[arraySize];
        
        // Scale max value with array size for better visualization
        maxValue = 100;
        
        // Generate values with good distribution
        for (int i = 0; i < arraySize; i++)
        {
            array[i] = random.Next(5, maxValue);
        }
    }
    
    private void CreateNearlySortedArray()
    {
        var random = new Random();
        
        // Create new array with exact size
        array = new int[arraySize];
        
        // Generate sorted array with good distribution
        for (int i = 0; i < arraySize; i++)
        {
            array[i] = 5 + (i * (maxValue - 5) / Math.Max(1, arraySize - 1));
        }
        
        // Swap ~10% of elements to make it nearly sorted
        int swaps = Math.Max(1, arraySize / 10);
        for (int i = 0; i < swaps; i++)
        {
            int pos1 = random.Next(arraySize);
            int pos2 = random.Next(Math.Max(0, pos1 - 5), Math.Min(arraySize, pos1 + 5));
            
            if (pos2 < arraySize)
            {
                (array[pos1], array[pos2]) = (array[pos2], array[pos1]);
            }
        }
    }
    
    private void CreateReversedArray()
    {
        // Create new array with exact size
        array = new int[arraySize];
        
        // Generate values in descending order
        for (int i = 0; i < arraySize; i++)
        {
            array[i] = maxValue - ((i * (maxValue - 5)) / Math.Max(1, arraySize - 1));
        }
    }
    
    private void CreateFewUniquesArray()
    {
        var random = new Random();
        
        // Create new array with exact size
        array = new int[arraySize];
        
        // Create only 5 unique values with good distribution
        int[] uniqueValues = new int[5];
        for (int i = 0; i < 5; i++)
        {
            uniqueValues[i] = 5 + (i * (maxValue - 5) / 4);
        }

        for (int i = 0; i < arraySize; i++)
        {
            array[i] = uniqueValues[random.Next(5)];
        }
    }
    
    // Public methods with state handling for UI interaction
    private void GenerateRandomArray(bool setType = true)
    {
        if (isSorting || isStepMode) return;
        
        if (setType) currentArrayType = "random";
        
        // Reset visualization state
        ResetSortingState();
        
        // Create the array
        CreateRandomArray();
        
        // Update UI
        StateHasChanged();
    }
    
    private void GenerateNearlySortedArray(bool setType = true)
    {
        if (isSorting || isStepMode) return;
        
        if (setType) currentArrayType = "nearlySorted";
        
        // Reset visualization state
        ResetSortingState();
        
        // Create the array
        CreateNearlySortedArray();
        
        // Update UI
        StateHasChanged();
    }
    
    private void GenerateReversedArray(bool setType = true)
    {
        if (isSorting || isStepMode) return;
        
        if (setType) currentArrayType = "reversed";
        
        // Reset visualization state
        ResetSortingState();
        
        // Create the array
        CreateReversedArray();
        
        // Update UI
        StateHasChanged();
    }
    
    private void GenerateFewUniquesArray(bool setType = true)
    {
        if (isSorting || isStepMode) return;
        
        if (setType) currentArrayType = "fewUniques";
        
        // Reset visualization state
        ResetSortingState();
        
        // Create the array
        CreateFewUniquesArray();
        
        // Update UI
        StateHasChanged();
    }
    
    // Reset array state
    private void ResetArray()
    {
        if (isSorting || isStepMode) return;
        
        ResetSortingState();
        
        // Keep the current array type when resetting
        switch (currentArrayType)
        {
            case "random":
                GenerateRandomArray();
                break;
            case "nearlySorted":
                GenerateNearlySortedArray();
                break;
            case "reversed":
                GenerateReversedArray();
                break;
            case "fewUniques":
                GenerateFewUniquesArray();
                break;
        }
    }
    
    private void ResetSortingState()
    {
        comparison1 = null;
        comparison2 = null;
        pivot = null;
        sortedIndices.Clear();
        comparisonCount = 0;
        swapCount = 0;
        isSortingCompleted = false;
        updateCounter = 0;
        currentStepExplanation = null;
        currentPseudocodeLine = 0;
    }

    // Step-by-step mode methods
    private void EnableStepMode()
    {
        if (isSorting) return;
        
        isStepMode = true;
        ResetSortingState();
        
        currentStepExplanation = "Ready to start step-by-step sorting with " + algorithms[selectedAlgorithm].Name;
        stopwatch.Restart();
        
        // Prepare the steps for the selected algorithm
        PrepareStepActions();
        StateHasChanged();
    }
    
    private void DisableStepMode()
    {
        isStepMode = false;
        stepActions.Clear();
        currentStepExplanation = null;
        currentPseudocodeLine = 0;
        stopwatch.Stop();
        ResetSortingState();
        StateHasChanged();
    }
    
    private void PrepareStepActions()
    {
        stepActions.Clear();
        
        switch (selectedAlgorithm)
        {
            case "bubble":
                PrepareBubbleSortSteps();
                break;
            case "insertion":
                PrepareInsertionSortSteps();
                break;
            case "selection":
                PrepareSelectionSortSteps();
                break;
            case "quick":
                PrepareQuickSortSteps();
                break;
            case "merge":
                PrepareMergeSortSteps();
                break;
        }
    }
    
    private void PrepareBubbleSortSteps()
    {
        // Initial explanation
        stepActions.Enqueue(() => {
            currentStepExplanation = "Bubble Sort begins. We'll compare adjacent elements and swap them if they're in the wrong order.";
            currentPseudocodeLine = 1;
            StateHasChanged();
        });
        
        // Loop through the array
        for (int i = 0; i < array.Length - 1; i++)
        {
            bool swapped = false;
            
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Starting pass {i+1}. We'll compare and possibly swap adjacent elements.";
                currentPseudocodeLine = 4;
                StateHasChanged();
            });
            
            for (int j = 0; j < array.Length - i - 1; j++)
            {
                int currentI = i;
                int currentJ = j;
                
                // Step 1: Compare elements
                stepActions.Enqueue(() => {
                    comparison1 = currentJ;
                    comparison2 = currentJ + 1;
                    currentStepExplanation = $"Comparing element at index {currentJ} (value: {array[currentJ]}) with element at index {currentJ+1} (value: {array[currentJ+1]})";
                    currentPseudocodeLine = 5;
                    comparisonCount++;
                    StateHasChanged();
                });
                
                // Step 2: Swap if needed
                stepActions.Enqueue(() => {
                    if (array[currentJ] > array[currentJ + 1])
                    {
                        (array[currentJ], array[currentJ + 1]) = (array[currentJ + 1], array[currentJ]);
                        swapped = true;
                        swapCount++;
                        currentStepExplanation = $"Swapped elements: {array[currentJ+1]} and {array[currentJ]} because {array[currentJ+1]} > {array[currentJ]}";
                        currentPseudocodeLine = 6;
                    }
                    else
                    {
                        currentStepExplanation = $"No swap needed as {array[currentJ]} ≤ {array[currentJ+1]}";
                    }
                    StateHasChanged();
                });
            }
            
            // Mark the largest element as sorted
            int lastElementIndex = array.Length - 1 - i;
            stepActions.Enqueue(() => {
                sortedIndices.Add(lastElementIndex);
                currentStepExplanation = $"Element at index {lastElementIndex} (value: {array[lastElementIndex]}) is now in its correct sorted position.";
                currentPseudocodeLine = 10;
                StateHasChanged();
            });
            
            if (!swapped)
            {
                stepActions.Enqueue(() => {
                    currentStepExplanation = "No swaps were made in this pass, which means the array is already sorted.";
                    currentPseudocodeLine = 12;
                    
                    // Mark all remaining elements as sorted
                    for (int k = 0; k < array.Length - i - 1; k++)
                    {
                        sortedIndices.Add(k);
                    }
                    StateHasChanged();
                });
                break;
            }
        }
        
        // Final step
        stepActions.Enqueue(() => {
            currentStepExplanation = "Bubble Sort completed! The array is now fully sorted.";
            comparison1 = null;
            comparison2 = null;
            isSortingCompleted = true;
            stopwatch.Stop();
            StateHasChanged();
        });
    }
    
    private void PrepareInsertionSortSteps()
    {
        // Initial explanation
        stepActions.Enqueue(() => {
            currentStepExplanation = "Insertion Sort begins. We'll build a sorted array one element at a time.";
            currentPseudocodeLine = 1;
            // The first element is already "sorted"
            sortedIndices.Add(0);
            StateHasChanged();
        });
        
        for (int i = 1; i < array.Length; i++)
        {
            int currentI = i;
            
            // Select current element to insert
            stepActions.Enqueue(() => {
                comparison1 = currentI;
                currentStepExplanation = $"Taking element at index {currentI} (value: {array[currentI]}) and inserting it into its correct position in the sorted part.";
                currentPseudocodeLine = 3;
                StateHasChanged();
            });
            
            int key = array[i];
            int j = i - 1;
            
            while (j >= 0 && array[j] > key)
            {
                int currentJ = j;
                
                // Compare with previous element
                stepActions.Enqueue(() => {
                    comparison2 = currentJ;
                    currentStepExplanation = $"Comparing with element at index {currentJ} (value: {array[currentJ]}). Since {array[currentJ]} > {key}, we need to shift it right.";
                    currentPseudocodeLine = 5;
                    comparisonCount++;
                    StateHasChanged();
                });
                
                // Shift element to the right
                stepActions.Enqueue(() => {
                    array[currentJ + 1] = array[currentJ];
                    swapCount++;
                    currentStepExplanation = $"Shifted element {array[currentJ]} one position to the right.";
                    currentPseudocodeLine = 6;
                    StateHasChanged();
                });
                
                j--;
            }
            
            // Insert element in correct position
            int insertPosition = j + 1;
            stepActions.Enqueue(() => {
                array[insertPosition] = key;
                sortedIndices.Add(currentI);
                currentStepExplanation = $"Inserted element {key} at index {insertPosition}. We've now sorted up to index {currentI}.";
                currentPseudocodeLine = 4;
                StateHasChanged();
            });
        }
        
        // Final step
        stepActions.Enqueue(() => {
            currentStepExplanation = "Insertion Sort completed! The array is now fully sorted.";
            comparison1 = null;
            comparison2 = null;
            isSortingCompleted = true;
            stopwatch.Stop();
            StateHasChanged();
        });
    }
    
    private void PrepareSelectionSortSteps()
    {
        // Initial explanation
        stepActions.Enqueue(() => {
            currentStepExplanation = "Selection Sort begins. We'll find the smallest unsorted element and move it to the beginning of the unsorted section.";
            currentPseudocodeLine = 1;
            StateHasChanged();
        });
        
        for (int i = 0; i < array.Length - 1; i++)
        {
            int currentI = i;
            
            // Start with current position as minimum
            stepActions.Enqueue(() => {
                comparison1 = currentI;
                currentStepExplanation = $"Looking for the smallest element in the unsorted portion (indices {currentI} to {array.Length-1}).";
                currentPseudocodeLine = 3;
                StateHasChanged();
            });
            
            int minIndex = i;
            
            for (int j = i + 1; j < array.Length; j++)
            {
                int currentJ = j;
                
                // Compare with current minimum
                stepActions.Enqueue(() => {
                    comparison2 = currentJ;
                    currentStepExplanation = $"Comparing element at index {currentJ} (value: {array[currentJ]}) with current minimum at index {minIndex} (value: {array[minIndex]}).";
                    currentPseudocodeLine = 5;
                    comparisonCount++;
                    StateHasChanged();
                });
                
                // Update minimum if needed
                if (array[j] < array[minIndex])
                {
                    int prevMinIndex = minIndex;
                    minIndex = j;
                    
                    stepActions.Enqueue(() => {
                        comparison1 = minIndex;
                        comparison2 = null;
                        currentStepExplanation = $"Found a new minimum: {array[minIndex]} at index {minIndex} (smaller than previous minimum {array[prevMinIndex]}).";
                        currentPseudocodeLine = 6;
                        StateHasChanged();
                    });
                }
            }
            
            // Swap if needed
            if (minIndex != i)
            {
                int finalMinIndex = minIndex;
                
                stepActions.Enqueue(() => {
                    (array[currentI], array[finalMinIndex]) = (array[finalMinIndex], array[currentI]);
                    swapCount++;
                    currentStepExplanation = $"Swapped the smallest element {array[currentI]} to its correct position at index {currentI}.";
                    currentPseudocodeLine = 9;
                    StateHasChanged();
                });
            }
            else
            {
                stepActions.Enqueue(() => {
                    currentStepExplanation = $"Element at index {currentI} (value: {array[currentI]}) is already the smallest in the unsorted portion.";
                    currentPseudocodeLine = 11;
                    StateHasChanged();
                });
            }
            
            // Mark element as sorted
            stepActions.Enqueue(() => {
                sortedIndices.Add(currentI);
                currentStepExplanation = $"Element at index {currentI} (value: {array[currentI]}) is now in its correct sorted position.";
                StateHasChanged();
            });
        }
        
        // Mark the last element as sorted
        stepActions.Enqueue(() => {
            sortedIndices.Add(array.Length - 1);
            currentStepExplanation = $"The last element at index {array.Length - 1} (value: {array[array.Length - 1]}) is automatically in its correct position.";
            StateHasChanged();
        });
        
        // Final step
        stepActions.Enqueue(() => {
            currentStepExplanation = "Selection Sort completed! The array is now fully sorted.";
            comparison1 = null;
            comparison2 = null;
            isSortingCompleted = true;
            stopwatch.Stop();
            StateHasChanged();
        });
    }
    
    private void PrepareQuickSortSteps()
    {
        // Initial explanation
        stepActions.Enqueue(() => {
            currentStepExplanation = "Quick Sort begins. We'll recursively partition the array around pivot elements.";
            currentPseudocodeLine = 1;
            StateHasChanged();
        });
        
        // Use a helper function to recursively prepare steps
        PrepareQuickSortStepsHelper(0, array.Length - 1);
        
        // Final step
        stepActions.Enqueue(() => {
            currentStepExplanation = "Quick Sort completed! The array is now fully sorted.";
            comparison1 = null;
            comparison2 = null;
            pivot = null;
            isSortingCompleted = true;
            stopwatch.Stop();
            StateHasChanged();
        });
    }
    
    private void PrepareQuickSortStepsHelper(int low, int high)
    {
        if (low < high)
        {
            int currentLow = low;
            int currentHigh = high;
            
            // Start partitioning
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Partitioning the subarray from index {currentLow} to {currentHigh}.";
                currentPseudocodeLine = 3;
                StateHasChanged();
            });
            
            // Get a copy of the current array state for pivot selection
            int[] currentArray = new int[array.Length];
            Array.Copy(array, currentArray, array.Length);
            
            // Choose the high element as pivot
            stepActions.Enqueue(() => {
                pivot = currentHigh;
                currentStepExplanation = $"Chosen pivot element: {currentArray[currentHigh]} at index {currentHigh}.";
                currentPseudocodeLine = 14;
                StateHasChanged();
            });
            
            int i = low - 1;
            
            for (int j = low; j < high; j++)
            {
                int currentJ = j;
                int currentI = i;
                
                // Compare element with pivot
                stepActions.Enqueue(() => {
                    comparison1 = currentJ;
                    comparison2 = currentHigh; // pivot
                    currentStepExplanation = $"Comparing element at index {currentJ} (value: {array[currentJ]}) with pivot {array[currentHigh]}.";
                    currentPseudocodeLine = 17;
                    comparisonCount++;
                    StateHasChanged();
                });
                
                // If element <= pivot, increment i and swap
                if (currentArray[j] <= currentArray[high])
                {
                    i++;
                    
                    if (i != j)
                    {
                        int newI = i;
                        stepActions.Enqueue(() => {
                            (array[newI], array[currentJ]) = (array[currentJ], array[newI]);
                            swapCount++;
                            currentStepExplanation = $"Element {array[currentJ]} is <= pivot {array[currentHigh]}, so we swap it with element at index {newI}.";
                            currentPseudocodeLine = 19;
                            StateHasChanged();
                        });
                    }
                    else
                    {
                        int newI = i;
                        stepActions.Enqueue(() => {
                            currentStepExplanation = $"Element {array[currentJ]} is <= pivot {array[currentHigh]}, but it's already in the correct position.";
                            currentPseudocodeLine = 18;
                            StateHasChanged();
                        });
                    }
                }
                else
                {
                    stepActions.Enqueue(() => {
                        currentStepExplanation = $"Element {array[currentJ]} is > pivot {array[currentHigh]}, so we leave it where it is.";
                        currentPseudocodeLine = 21;
                        StateHasChanged();
                    });
                }
                
                // Update the current array copy
                Array.Copy(array, currentArray, array.Length);
            }
            
            // Put pivot in its correct position
            int pivotCorrectIndex = i + 1;
            stepActions.Enqueue(() => {
                (array[pivotCorrectIndex], array[currentHigh]) = (array[currentHigh], array[pivotCorrectIndex]);
                swapCount++;
                currentStepExplanation = $"Moving pivot {array[pivotCorrectIndex]} to its correct position at index {pivotCorrectIndex}.";
                currentPseudocodeLine = 22;
                pivot = pivotCorrectIndex;
                StateHasChanged();
            });
            
            // Mark pivot as sorted
            stepActions.Enqueue(() => {
                sortedIndices.Add(pivotCorrectIndex);
                currentStepExplanation = $"Pivot element at index {pivotCorrectIndex} (value: {array[pivotCorrectIndex]}) is now in its correct sorted position.";
                currentPseudocodeLine = 23;
                pivot = null;
                StateHasChanged();
            });
            
            // Update the partition result for recursion
            int partitionResult = pivotCorrectIndex;
            
            // Prepare steps for left partition
            if (low < partitionResult - 1)
            {
                stepActions.Enqueue(() => {
                    currentStepExplanation = $"Recursively sorting left subarray from index {currentLow} to {partitionResult - 1}.";
                    currentPseudocodeLine = 4;
                    StateHasChanged();
                });
                PrepareQuickSortStepsHelper(low, partitionResult - 1);
            }
            
            // Prepare steps for right partition
            if (partitionResult + 1 < high)
            {
                stepActions.Enqueue(() => {
                    currentStepExplanation = $"Recursively sorting right subarray from index {partitionResult + 1} to {currentHigh}.";
                    currentPseudocodeLine = 5;
                    StateHasChanged();
                });
                PrepareQuickSortStepsHelper(partitionResult + 1, high);
            }
        }
        else if (low == high)
        {
            // Single element is already sorted
            int singleElementIndex = low;
            stepActions.Enqueue(() => {
                sortedIndices.Add(singleElementIndex);
                currentStepExplanation = $"Single element at index {singleElementIndex} (value: {array[singleElementIndex]}) is automatically sorted.";
                currentPseudocodeLine = 2;
                StateHasChanged();
            });
        }
    }
    
    private void PrepareMergeSortSteps()
    {
        // Initial explanation
        stepActions.Enqueue(() => {
            currentStepExplanation = "Merge Sort begins. We'll recursively divide the array, sort the parts, and merge them back together.";
            currentPseudocodeLine = 1;
            StateHasChanged();
        });
        
        // Use a helper function to recursively prepare steps
        PrepareMergeSortStepsHelper(0, array.Length - 1);
        
        // Final step
        stepActions.Enqueue(() => {
            currentStepExplanation = "Merge Sort completed! The array is now fully sorted.";
            comparison1 = null;
            comparison2 = null;
            isSortingCompleted = true;
            stopwatch.Stop();
            StateHasChanged();
        });
    }
    
    private void PrepareMergeSortStepsHelper(int left, int right)
    {
        if (left < right)
        {
            int currentLeft = left;
            int currentRight = right;
            
            // Calculate middle point
            int mid = (left + right) / 2;
            int currentMid = mid;
            
            // Divide
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Dividing the array into two halves: [{currentLeft}...{currentMid}] and [{currentMid+1}...{currentRight}].";
                currentPseudocodeLine = 3;
                StateHasChanged();
            });
            
            // Recurse on left half
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Recursively sorting the left half: indices {currentLeft} to {currentMid}.";
                currentPseudocodeLine = 4;
                StateHasChanged();
            });
            PrepareMergeSortStepsHelper(left, mid);
            
            // Recurse on right half
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Recursively sorting the right half: indices {currentMid+1} to {currentRight}.";
                currentPseudocodeLine = 5;
                StateHasChanged();
            });
            PrepareMergeSortStepsHelper(mid + 1, right);
            
            // Merge the halves
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Merging the two sorted halves: [{currentLeft}...{currentMid}] and [{currentMid+1}...{currentRight}].";
                currentPseudocodeLine = 6;
                StateHasChanged();
            });
            
            // Get a copy of the current array state for merge visualization
            int[] currentArray = new int[array.Length];
            Array.Copy(array, currentArray, array.Length);
            
            // Create temporary arrays for the merge
            int n1 = mid - left + 1;
            int n2 = right - mid;
            int[] L = new int[n1];
            int[] R = new int[n2];
            
            for (int i = 0; i < n1; i++)
                L[i] = currentArray[left + i];
            for (int j = 0; j < n2; j++)
                R[j] = currentArray[mid + 1 + j];
            
            // Steps to show the creation of temporary arrays
            stepActions.Enqueue(() => {
                currentStepExplanation = $"Created temporary arrays for the two halves to facilitate merging.";
                currentPseudocodeLine = 13;
                StateHasChanged();
            });
            
            // Merge the arrays
            int i1 = 0, i2 = 0, k = left;
            
            while (i1 < n1 && i2 < n2)
            {
                int currentI = i1;
                int currentJ = i2;
                int currentK = k;
                
                // Compare elements from both halves
                stepActions.Enqueue(() => {
                    comparison1 = currentLeft + currentI;
                    comparison2 = currentMid + 1 + currentJ;
                    currentStepExplanation = $"Comparing element L[{currentI}]={L[currentI]} with R[{currentJ}]={R[currentJ]}.";
                    currentPseudocodeLine = 19;
                    comparisonCount++;
                    StateHasChanged();
                });
                
                if (L[i1] <= R[i2])
                {
                    // Take from left array
                    stepActions.Enqueue(() => {
                        array[currentK] = L[currentI];
                        currentStepExplanation = $"Placing the smaller element L[{currentI}]={L[currentI]} into position {currentK}.";
                        currentPseudocodeLine = 20;
                        swapCount++;
                        StateHasChanged();
                    });
                    i1++;
                }
                else
                {
                    // Take from right array
                    stepActions.Enqueue(() => {
                        array[currentK] = R[currentJ];
                        currentStepExplanation = $"Placing the smaller element R[{currentJ}]={R[currentJ]} into position {currentK}.";
                        currentPseudocodeLine = 23;
                        swapCount++;
                        StateHasChanged();
                    });
                    i2++;
                }
                
                k++;
            }
            
            // Copy remaining elements from left array
            while (i1 < n1)
            {
                int currentI = i1;
                int currentK = k;
                
                stepActions.Enqueue(() => {
                    array[currentK] = L[currentI];
                    currentStepExplanation = $"Copying remaining element L[{currentI}]={L[currentI]} to position {currentK}.";
                    currentPseudocodeLine = 29;
                    swapCount++;
                    StateHasChanged();
                });
                
                i1++;
                k++;
            }
            
            // Copy remaining elements from right array
            while (i2 < n2)
            {
                int currentJ = i2;
                int currentK = k;
                
                stepActions.Enqueue(() => {
                    array[currentK] = R[currentJ];
                    currentStepExplanation = $"Copying remaining element R[{currentJ}]={R[currentJ]} to position {currentK}.";
                    currentPseudocodeLine = 30;
                    swapCount++;
                    StateHasChanged();
                });
                
                i2++;
                k++;
            }
            
            // Mark the merged portion as sorted (temporarily for visualization)
            stepActions.Enqueue(() => {
                for (int idx = currentLeft; idx <= currentRight; idx++)
                {
                    sortedIndices.Add(idx);
                }
                currentStepExplanation = $"Completed merging of subarray from indices {currentLeft} to {currentRight}.";
                currentPseudocodeLine = 7;
                StateHasChanged();
            });
            
            // Clear sorted indices for recursive visualization (except at the end)
            if (!(left == 0 && right == array.Length - 1))
            {
                stepActions.Enqueue(() => {
                    sortedIndices.Clear();
                    currentStepExplanation = $"Continuing with other subarrays...";
                    StateHasChanged();
                });
            }
        }
    }
    
    private void StepForward()
    {
        if (!isStepMode) return;
        
        if (stepActions.Count > 0)
        {
            var action = stepActions.Dequeue();
            action.Invoke();
            
            // Force UI update
            StateHasChanged();
        }
        else if (isStepMode)
        {
            // Complete the sorting when all steps are done
            isStepMode = false;
            isSortingCompleted = true;
            
            // Ensure all elements are marked as sorted
            for (int i = 0; i < array.Length; i++)
            {
                sortedIndices.Add(i);
            }
            
            currentStepExplanation = "Sorting completed!";
            stopwatch.Stop();
            StateHasChanged();
        }
    }

    // Sorting control methods
    private async Task StartSort()
    {
        if (isSorting || isStepMode) return;

        isSorting = true;
        isSortingCompleted = false;
        ResetSortingState();

        cts = new CancellationTokenSource();
        stopwatch.Restart();

        try
        {
            switch (selectedAlgorithm)
            {
                case "bubble":
                    await BubbleSort(cts.Token);
                    break;
                case "insertion":
                    await InsertionSort(cts.Token);
                    break;
                case "selection":
                    await SelectionSort(cts.Token);
                    break;
                case "quick":
                    await QuickSort(0, array.Length - 1, cts.Token);
                    break;
                case "merge":
                    await MergeSort(0, array.Length - 1, cts.Token);
                    break;
            }

            // Mark all as sorted when complete
            for (int i = 0; i < array.Length; i++)
            {
                sortedIndices.Add(i);
            }

            comparison1 = null;
            comparison2 = null;
            pivot = null;
            stopwatch.Stop();
            isSortingCompleted = true;
            
            await InvokeAsync(StateHasChanged);
        }
        catch (OperationCanceledException)
        {
            // Sorting was cancelled
            stopwatch.Stop();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during sorting: {ex.Message}");
            stopwatch.Stop();
        }
        finally
        {
            isSorting = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void StopSort()
    {
        cts?.Cancel();
        cts?.Dispose();
        cts = null;
        isSorting = false;
        stopwatch.Stop();
    }

    // Update UI helper method with throttling
    private async Task UpdateUI(CancellationToken token)
    {
        updateCounter++;
        
        // Throttle updates for better performance
        if (array.Length <= 10 || updateCounter >= GetUpdateThreshold())
        {
            StateHasChanged();
            updateCounter = 0;
            
            try
            {
                await Task.Delay(GetDelay(), token);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Delay error: {ex.Message}");
            }
        }
    }

    private int GetUpdateThreshold()
    {
        // More aggressive throttling for large arrays
        if (array.Length <= 10) return 1;
        if (array.Length <= 20) return 2;
        if (array.Length <= 30) return 3;
        return 4;
    }

    // Sorting algorithm implementations
    private async Task BubbleSort(CancellationToken token)
    {
        for (int i = 0; i < array.Length - 1; i++)
        {
            bool swapped = false;

            for (int j = 0; j < array.Length - i - 1; j++)
            {
                token.ThrowIfCancellationRequested();

                comparison1 = j;
                comparison2 = j + 1;
                comparisonCount++;
                
                await UpdateUI(token);

                if (array[j] > array[j + 1])
                {
                    // Swap elements
                    (array[j], array[j + 1]) = (array[j + 1], array[j]);
                    swapped = true;
                    swapCount++;
                    await UpdateUI(token);
                }
            }

            // Mark the last element as sorted
            sortedIndices.Add(array.Length - 1 - i);

            // If no swapping occurred, array is sorted
            if (!swapped)
            {
                // Mark all remaining elements as sorted
                for (int k = 0; k < array.Length - i - 1; k++)
                {
                    sortedIndices.Add(k);
                }
                break;
            }
        }
    }

    private async Task InsertionSort(CancellationToken token)
    {
        for (int i = 1; i < array.Length; i++)
        {
            token.ThrowIfCancellationRequested();
            
            int key = array[i];
            int j = i - 1;
            
            comparison1 = i;
            
            while (j >= 0)
            {
                token.ThrowIfCancellationRequested();
                
                comparison2 = j;
                comparisonCount++;
                await UpdateUI(token);
                
                if (array[j] > key)
                {
                    array[j + 1] = array[j];
                    j--;
                    swapCount++;
                    await UpdateUI(token);
                }
                else
                {
                    break;
                }
            }
            
            array[j + 1] = key;
            sortedIndices.Add(j + 1);
            await UpdateUI(token);
        }
    }

    private async Task SelectionSort(CancellationToken token)
    {
        for (int i = 0; i < array.Length - 1; i++)
        {
            token.ThrowIfCancellationRequested();
            
            int minIndex = i;
            comparison1 = i;
            
            for (int j = i + 1; j < array.Length; j++)
            {
                token.ThrowIfCancellationRequested();
                
                comparison2 = j;
                comparisonCount++;
                await UpdateUI(token);
                
                if (array[j] < array[minIndex])
                {
                    minIndex = j;
                    comparison1 = minIndex;
                    await UpdateUI(token);
                }
            }
            
            // Swap the found minimum element with the first element
            if (minIndex != i)
            {
                (array[i], array[minIndex]) = (array[minIndex], array[i]);
                swapCount++;
                await UpdateUI(token);
            }
            
            sortedIndices.Add(i);
        }
        
        // Add the last element as sorted
        sortedIndices.Add(array.Length - 1);
    }

    private async Task QuickSort(int low, int high, CancellationToken token)
    {
        if (low < high)
        {
            token.ThrowIfCancellationRequested();

            int pivotIndex = await Partition(low, high, token);

            // Mark pivot as sorted
            sortedIndices.Add(pivotIndex);
            await UpdateUI(token);

            await QuickSort(low, pivotIndex - 1, token);
            await QuickSort(pivotIndex + 1, high, token);
        }
        else if (low >= 0 && low < array.Length)
        {
            // Single element is sorted
            sortedIndices.Add(low);
            await UpdateUI(token);
        }
    }

    private async Task<int> Partition(int low, int high, CancellationToken token)
    {
        // Using last element as pivot
        int pivotValue = array[high];
        pivot = high;
        
        int i = low - 1;

        for (int j = low; j < high; j++)
        {
            token.ThrowIfCancellationRequested();

            comparison1 = j;
            comparison2 = high; // pivot
            comparisonCount++;
            await UpdateUI(token);

            if (array[j] <= pivotValue)
            {
                i++;
                (array[i], array[j]) = (array[j], array[i]);
                swapCount++;
                await UpdateUI(token);
            }
        }

        // Put pivot in correct position
        (array[i + 1], array[high]) = (array[high], array[i + 1]);
        swapCount++;
        
        // Update visualization
        comparison1 = i + 1;
        comparison2 = high;
        await UpdateUI(token);
        
        pivot = null;
        return i + 1;
    }

    private async Task MergeSort(int left, int right, CancellationToken token)
    {
        if (left < right)
        {
            token.ThrowIfCancellationRequested();
            
            int mid = (left + right) / 2;
            
            // Sort first and second halves
            await MergeSort(left, mid, token);
            await MergeSort(mid + 1, right, token);
            
            // Merge the sorted halves
            await Merge(left, mid, right, token);
        }
    }

    private async Task Merge(int left, int mid, int right, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        
        // Create temporary arrays
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] L = new int[n1];
        int[] R = new int[n2];
        
        // Copy data to temp arrays
        for (int i = 0; i < n1; i++)
        {
            L[i] = array[left + i];
        }
        
        for (int j = 0; j < n2; j++)
        {
            R[j] = array[mid + 1 + j];
        }
        
        // Merge the temp arrays back into array[left..right]
        int i1 = 0, i2 = 0;
        int k = left;
        
        while (i1 < n1 && i2 < n2)
        {
            token.ThrowIfCancellationRequested();
            
            comparison1 = left + i1;
            comparison2 = mid + 1 + i2;
            comparisonCount++;
            
            await UpdateUI(token);
            
            if (L[i1] <= R[i2])
            {
                array[k] = L[i1];
                i1++;
            }
            else
            {
                array[k] = R[i2];
                i2++;
            }
            
            k++;
            swapCount++;
            await UpdateUI(token);
        }
        
        // Copy remaining elements of L[] if any
        while (i1 < n1)
        {
            token.ThrowIfCancellationRequested();
            array[k] = L[i1];
            i1++;
            k++;
            swapCount++;
            await UpdateUI(token);
        }
        
        // Copy remaining elements of R[] if any
        while (i2 < n2)
        {
            token.ThrowIfCancellationRequested();
            array[k] = R[i2];
            i2++;
            k++;
            swapCount++;
            await UpdateUI(token);
        }
        
        // Mark the merged portion as sorted
        for (int i = left; i <= right; i++)
        {
            sortedIndices.Add(i);
        }
    }

    private int GetDelay()
    {
        // Faster speeds with more intuitive scaling at higher percentages
        return (int)(500 * Math.Pow(0.98, speed));
    }
    
    // Performance analysis methods
    private string GetEfficiencyRating()
    {
        int totalOps = comparisonCount + swapCount;
        int n = array.Length;
        double nLogN = n * Math.Log2(n);
        double nSquared = n * n;
        
        if (totalOps <= 1.5 * n) return "Excellent";
        if (totalOps <= 2 * nLogN) return "Very Good";
        if (totalOps <= 4 * nLogN) return "Good";
        if (totalOps <= nSquared / 2) return "Average";
        if (totalOps <= nSquared) return "Below Average";
        return "Poor";
    }
    
    private string GetEfficiencyColor()
    {
        string rating = GetEfficiencyRating();
        return rating switch
        {
            "Excellent" => "text-green-600 font-medium",
            "Very Good" => "text-green-500 font-medium",
            "Good" => "text-blue-500 font-medium",
            "Average" => "text-yellow-500 font-medium",
            "Below Average" => "text-orange-500 font-medium",
            "Poor" => "text-red-500 font-medium",
            _ => "text-gray-700"
        };
    }

    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
    }
    
    // Algorithm info class
    private class AlgorithmInfo
    {
        public string Name { get; set; } = "";
        public string BestTime { get; set; } = "";
        public string AvgTime { get; set; } = "";
        public string WorstTime { get; set; } = "";
        public string Space { get; set; } = "";
        public bool IsStable { get; set; }
        public string Description { get; set; } = "";
        public string Pseudocode { get; set; } = "";
    }
}