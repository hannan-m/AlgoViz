@namespace AlgorithmVisualizer.Components.Trees
@using AlgorithmVisualizer.Models.TreeModels
@using AlgorithmVisualizer.Models
@using AlgorithmVisualizer.Services.Algorithms.Interfaces
@using AlgorithmVisualizer.Utilities
@inject IJSRuntime JSRuntime

<div class="tree-container">
    <div class="tree-controls">
        <div class="control-section">
            <h3><span class="oi oi-cog me-2"></span>Algorithm</h3>
            <select @bind="selectedAlgorithm" class="form-select mb-3">
                @foreach (var algorithm in Algorithms)
                {
                    <option value="@algorithm.Name">@algorithm.Name</option>
                }
            </select>
        </div>

        <div class="control-section">
            <h3><span class="oi oi-wrench me-2"></span>Operations</h3>
            <div class="operation-selector mb-3">
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" id="insertOperation" name="operation"
                           value="@TreeOperationType.Insert" checked="@(selectedOperation == TreeOperationType.Insert)"
                           @onchange="() => selectedOperation = TreeOperationType.Insert">
                    <label class="form-check-label" for="insertOperation">
                        <span class="oi oi-plus me-1 text-success"></span> Insert
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" id="deleteOperation" name="operation"
                           value="@TreeOperationType.Delete" checked="@(selectedOperation == TreeOperationType.Delete)"
                           @onchange="() => selectedOperation = TreeOperationType.Delete">
                    <label class="form-check-label" for="deleteOperation">
                        <span class="oi oi-minus me-1 text-danger"></span> Delete
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" id="searchOperation" name="operation"
                           value="@TreeOperationType.Search" checked="@(selectedOperation == TreeOperationType.Search)"
                           @onchange="() => selectedOperation = TreeOperationType.Search">
                    <label class="form-check-label" for="searchOperation">
                        <span class="oi oi-magnifying-glass me-1 text-primary"></span> Search
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="radio" id="traverseOperation" name="operation"
                           value="@TreeOperationType.Traverse"
                           checked="@(selectedOperation == TreeOperationType.Traverse)"
                           @onchange="() => selectedOperation = TreeOperationType.Traverse">
                    <label class="form-check-label" for="traverseOperation">
                        <span class="oi oi-list me-1 text-info"></span> Traverse
                    </label>
                </div>
            </div>

            @if (selectedOperation != TreeOperationType.Traverse)
            {
                <div class="form-group mb-3">
                    <label for="nodeValue" class="mb-2">Node Value:</label>
                    <input type="number" class="form-control" id="nodeValue" @bind="nodeValue"/>
                    @if (nodeValueError)
                    {
                        <div class="validation-message">
                            <span class="oi oi-warning"></span> Please enter a valid node value.
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="form-group mb-3">
                    <label for="traversalType" class="mb-2">Traversal Type:</label>
                    <select @bind="selectedTraversalType" class="form-select">
                        <option value="InOrder">In-Order</option>
                        <option value="PreOrder">Pre-Order</option>
                        <option value="PostOrder">Post-Order</option>
                        <option value="LevelOrder">Level-Order</option>
                    </select>
                </div>
            }

            <div class="d-grid gap-2 mb-3">
                <button @onclick="PerformOperationAsync" class="btn btn-primary" disabled="@isVisualizing">
                    <span class="oi oi-media-play me-2"></span>Visualize
                </button>
                <button @onclick="StopVisualization" class="btn btn-danger" disabled="@(!isVisualizing)">
                    <span class="oi oi-media-stop me-2"></span>Stop
                </button>
                <button @onclick="ResetTree" class="btn btn-secondary" disabled="@isVisualizing">
                    <span class="oi oi-reload me-2"></span>Reset Tree
                </button>
                <button @onclick="GenerateRandomTree" class="btn btn-info" disabled="@isVisualizing">
                    <span class="oi oi-random me-2"></span>Generate Random Tree
                </button>
            </div>
        </div>

        @if (CurrentAlgorithm != null)
        {
            <div class="control-section">
                <h3><span class="oi oi-info me-2"></span>Algorithm Details</h3>
                <div class="algorithm-info-card">
                    <div class="mb-2">
                        <strong>Description:</strong> @CurrentAlgorithm.Description
                    </div>
                    <div class="mb-2">
                        <strong>Time Complexity:</strong> @CurrentAlgorithm.TimeComplexity
                    </div>
                    <div>
                        <strong>Space Complexity:</strong> @CurrentAlgorithm.SpaceComplexity
                    </div>
                </div>
            </div>
        }

        @if (Statistics != null)
        {
            <div class="control-section">
                <h3><span class="oi oi-graph me-2"></span>Statistics</h3>
                <div class="stats-card">
                    <div class="mb-2">
                        <strong>Execution Time:</strong> @Statistics.ExecutionTimeMs.ToString("F2") ms
                    </div>
                    <div class="mb-2">
                        <strong>Steps:</strong> @Statistics.StepCount
                    </div>
                    <div class="mb-2">
                        <strong>Nodes Processed:</strong> @Statistics.ElementsProcessed
                    </div>
                    @if (!string.IsNullOrEmpty(Statistics.AdditionalMetrics))
                    {
                        <div>
                            <strong>Additional Info:</strong> @Statistics.AdditionalMetrics
                        </div>
                    }
                </div>
            </div>
        }
    </div>

    <div class="tree-visualization">
        <!-- SVG tree visualization with increased viewBox to accommodate deeper trees -->
        <svg class="tree-svg" viewBox="-10 -2 20 25">
            @if (CurrentTreeState?.Root != null)
            {
                <g class="tree-container-group">
                    <!-- Draw edges first so nodes are on top -->
                    @DrawTreeEdges(CurrentTreeState.Root)
                    <!-- Draw nodes after edges -->
                    @DrawTreeNodes(CurrentTreeState.Root)
                </g>
            }
            else
            {
                <p x="0" y="5" text-anchor="middle" class="empty-tree-message">
                    Empty Tree
                </p>
            }
        </svg>

        @if (isVisualizing)
        {
            <div class="loading-overlay">
                <div class="spinner"></div>
                <div>Processing...</div>
            </div>
        }

        @if (CurrentStep != null)
        {
            <div class="step-description">
                <span class="oi oi-info me-2"></span>
                <p>Step @(CurrentStep.StepNumber + 1): @CurrentStep.Description</p>
            </div>
        }

        @if (AlgorithmSteps != null && AlgorithmSteps.Any())
        {
            <div class="step-controls">
                <button @onclick="() => GoToStep(0)" class="btn btn-outline-primary"
                        disabled="@(currentStepIndex <= 0)">
                    <span class="oi oi-media-skip-backward me-1"></span> First
                </button>
                <button @onclick="PreviousStep" class="btn btn-outline-primary" disabled="@(currentStepIndex <= 0)">
                    <span class="oi oi-media-step-backward me-1"></span> Previous
                </button>
                <span class="step-counter">Step @(currentStepIndex + 1) of @AlgorithmSteps.Count</span>
                <button @onclick="NextStep" class="btn btn-outline-primary"
                        disabled="@(currentStepIndex >= AlgorithmSteps.Count - 1)">
                    <span class="oi oi-media-step-forward me-1"></span> Next
                </button>
                <button @onclick="() => GoToStep(AlgorithmSteps.Count - 1)" class="btn btn-outline-primary"
                        disabled="@(currentStepIndex >= AlgorithmSteps.Count - 1)">
                    <span class="oi oi-media-skip-forward me-1"></span> Last
                </button>

                <div class="auto-play-control ms-2">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="autoPlay" @onchange="ToggleAutoPlay">
                        <label class="form-check-label" for="autoPlay">Auto Play</label>
                    </div>
                </div>

                <div class="speed-control ms-auto">
                    <label class="form-label mb-0 me-2">Speed: @visualizationSpeed</label>
                    <input type="range" min="1" max="10" step="1" @bind="visualizationSpeed" class="form-range"
                           style="width: 120px;"/>
                </div>
            </div>
        }
    </div>
</div>



@code {
    [Parameter] public List<ITreeAlgorithm> Algorithms { get; set; } = new List<ITreeAlgorithm>();

    private TreeState TreeState { get; set; } = new TreeState();
    private TreeState CurrentTreeState => CurrentStep?.State ?? TreeState;

    private string selectedAlgorithm;
    private ITreeAlgorithm CurrentAlgorithm => Algorithms?.FirstOrDefault(a => a.Name == selectedAlgorithm);

    private TreeOperationType selectedOperation = TreeOperationType.Insert;
    private string selectedTraversalType = "InOrder"; // Default traversal type
    private int nodeValue = 10;
    private bool nodeValueError = false;

    private bool isVisualizing = false;
    private AlgorithmStatistics Statistics { get; set; }

    private List<AlgorithmStep<TreeState>> AlgorithmSteps { get; set; }
    private int currentStepIndex = -1;

    private AlgorithmStep<TreeState> CurrentStep =>
        currentStepIndex >= 0 && currentStepIndex < AlgorithmSteps?.Count
            ? AlgorithmSteps[currentStepIndex]
            : null;

    private bool autoPlay = false;
    private int visualizationSpeed = 2;
    private System.Threading.CancellationTokenSource autoPlayCancellationTokenSource;
    private System.Threading.CancellationTokenSource operationCancellationTokenSource;

    private ThrottledUpdater throttledUpdater = new ThrottledUpdater(50);

    protected override void OnInitialized()
    {
        // Select first algorithm by default
        if (Algorithms != null && Algorithms.Any())
        {
            selectedAlgorithm = Algorithms.First().Name;
        }

        // Initialize with some sample data
        GenerateRandomTree();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Ensure tree is properly initialized
            await Task.Delay(100);
            StateHasChanged();
        }
    }

    // Toggle auto-play and handle its execution
    private async Task ToggleAutoPlay(ChangeEventArgs e)
    {
        autoPlay = (bool)e.Value;

        if (autoPlay)
        {
            await StartAutoPlay();
        }
        else
        {
            StopAutoPlay();
        }
    }

    // Start auto-play with proper cancellation handling
    private async Task StartAutoPlay()
    {
        if (AlgorithmSteps == null || AlgorithmSteps.Count == 0 || currentStepIndex >= AlgorithmSteps.Count - 1)
        {
            autoPlay = false;
            return;
        }

        // Cancel any existing auto-play
        StopAutoPlay();

        // Create new cancellation token source
        autoPlayCancellationTokenSource = new System.Threading.CancellationTokenSource();
        var token = autoPlayCancellationTokenSource.Token;

        try
        {
            // Continue auto-play until canceled or reached the end
            while (autoPlay && currentStepIndex < AlgorithmSteps.Count - 1 && !token.IsCancellationRequested)
            {
                await Task.Delay(700 / visualizationSpeed);

                if (token.IsCancellationRequested)
                    break;

                await NextStep();
                StateHasChanged();

                // Check if we've reached the end
                if (currentStepIndex >= AlgorithmSteps.Count - 1)
                {
                    autoPlay = false;
                    break;
                }
            }
        }
        catch (System.Threading.Tasks.TaskCanceledException)
        {
            // Task was canceled, ignore
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error during auto-play: {ex.Message}");
        }
    }

    // Stop auto-play
    private void StopAutoPlay()
    {
        autoPlayCancellationTokenSource?.Cancel();
        autoPlayCancellationTokenSource?.Dispose();
        autoPlayCancellationTokenSource = null;
    }

    private void ResetTree()
    {
        // Stop any active auto-play
        StopAutoPlay();
        autoPlay = false;

        TreeState = new TreeState();

        // Reset visualization state
        AlgorithmSteps = null;
        currentStepIndex = -1;
        Statistics = null;
        isVisualizing = false;
        nodeValueError = false;

        // Cancel any ongoing visualization
        operationCancellationTokenSource?.Cancel();

        // Force UI update
        StateHasChanged();
    }

    private void GenerateRandomTree()
    {
        ResetTree();

        try
        {
            // Generate a random tree with values between 1-100
            var random = new Random();
            int nodeCount = random.Next(7, 20); // Generate 7-20 nodes for potentially deeper trees

            // Create a sorted list of unique values
            var values = new List<int>();
            for (int i = 0; i < nodeCount; i++)
            {
                int val;
                do
                {
                    val = random.Next(1, 100);
                } while (values.Contains(val));

                values.Add(val);
            }

            // Insert values in a balanced way to create a somewhat balanced tree
            values.Sort(); // Sort values
            InsertBalanced(values, 0, values.Count - 1);

            // Calculate positions for the tree with improved spacing algorithm
            if (TreeState.Root != null)
            {
                CalculateNodePositionsImproved(TreeState.Root);
            }

            // Force UI update
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error generating random tree: {ex.Message}");
        }
    }

    private void InsertBalanced(List<int> values, int start, int end)
    {
        if (start > end)
            return;

        // Get the middle element and insert it
        int mid = (start + end) / 2;
        InsertNode(values[mid]);

        // Recursively insert left and right halves
        InsertBalanced(values, start, mid - 1);
        InsertBalanced(values, mid + 1, end);
    }

    private void InsertNode(int value)
    {
        // Simple BST insertion without visualization
        TreeState.Root = InsertNodeRecursive(TreeState.Root, value);
    }

    private TreeNode InsertNodeRecursive(TreeNode root, int value)
    {
        // If the tree is empty, create a new node
        if (root == null)
        {
            return new TreeNode { Value = value };
        }

        // Otherwise, recur down the tree
        if (value < root.Value)
        {
            root.Left = InsertNodeRecursive(root.Left, value);
        }
        else if (value > root.Value)
        {
            root.Right = InsertNodeRecursive(root.Right, value);
        }
        // Equal values are not allowed in this BST implementation

        return root;
    }

    private async Task PerformOperationAsync()
    {
        if (CurrentAlgorithm == null)
        {
            return;
        }

        // Stop any active auto-play first
        StopAutoPlay();
        autoPlay = false;

        // Clear previous error
        nodeValueError = false;

        // Validate input for operations that require a value
        if (selectedOperation != TreeOperationType.Traverse && nodeValue <= 0)
        {
            nodeValueError = true;
            return;
        }

        // Reset visualization state
        AlgorithmSteps = null;
        currentStepIndex = -1;
        Statistics = null;

        // Set visualization state
        isVisualizing = true;

        // Create a cancellation token source
        operationCancellationTokenSource = new System.Threading.CancellationTokenSource();

        try
        {
            // Track performance
            using var tracker = new PerformanceTracker();
            tracker.Start();

            // Pass traversal type if the operation is Traverse
            Dictionary<string, object> parameters = new Dictionary<string, object>();
            if (selectedOperation == TreeOperationType.Traverse)
            {
                parameters["traversalType"] = selectedTraversalType;
            }

            // Get algorithm steps
            AlgorithmSteps = (await CurrentAlgorithm.GetStepsAsync(
                TreeState,
                selectedOperation,
                selectedOperation != TreeOperationType.Traverse ? nodeValue : (int?)null,
                parameters
            )).ToList();

            if (AlgorithmSteps != null && AlgorithmSteps.Any())
            {
                // Update all node positions in each step with improved positioning algorithm
                foreach (var step in AlgorithmSteps)
                {
                    if (step.State?.Root != null)
                    {
                        // Use improved positioning algorithm
                        CalculateNodePositionsImproved(step.State.Root);
                    }
                }

                // Get the final tree state
                TreeState = DeepCloneTreeState(AlgorithmSteps.Last().State);

                // Record statistics
                tracker.RecordStep();
                foreach (var step in AlgorithmSteps)
                {
                    tracker.RecordElementsProcessed();
                }

                // Set additional metrics based on operation
                string metricMessage = selectedOperation switch
                {
                    TreeOperationType.Insert => $"Node {nodeValue} inserted",
                    TreeOperationType.Delete => $"Node {nodeValue} deleted",
                    TreeOperationType.Search => AlgorithmSteps.Last().Description.Contains("found")
                        ? $"Node {nodeValue} found"
                        : $"Node {nodeValue} not found",
                    TreeOperationType.Traverse => $"{selectedTraversalType} traversal complete",
                    _ => ""
                };

                tracker.SetAdditionalMetrics(metricMessage);

                // Start visualization from step 0
                if (AlgorithmSteps.Any())
                {
                    currentStepIndex = 0;
                }
            }

            // Stop performance tracking
            Statistics = tracker.Stop();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error during visualization: {ex}");
        }
        finally
        {
            isVisualizing = false;
            StateHasChanged(); // Make sure UI is updated
        }
    }

    // Create a deep clone of TreeState to avoid reference issues
    private TreeState DeepCloneTreeState(TreeState state)
    {
        if (state == null) return null;

        var newState = new TreeState
        {
            TargetValue = state.TargetValue,
            CurrentPath = new List<TreeNode>(state.CurrentPath)
        };

        if (state.Root != null)
        {
            newState.Root = DeepCloneNode(state.Root);
        }

        return newState;
    }

    // Create a deep clone of TreeNode and its children
    private TreeNode DeepCloneNode(TreeNode node)
    {
        if (node == null) return null;

        var newNode = new TreeNode
        {
            Value = node.Value,
            X = node.X,
            Y = node.Y,
            IsActive = node.IsActive,
            IsHighlighted = node.IsHighlighted,
            IsResult = node.IsResult
        };

        if (node.Left != null)
        {
            newNode.Left = DeepCloneNode(node.Left);
        }

        if (node.Right != null)
        {
            newNode.Right = DeepCloneNode(node.Right);
        }

        return newNode;
    }

    private void StopVisualization()
    {
        // Cancel ongoing operation
        operationCancellationTokenSource?.Cancel();
        operationCancellationTokenSource?.Dispose();
        operationCancellationTokenSource = null;

        // Stop auto-play
        StopAutoPlay();
        autoPlay = false;

        isVisualizing = false;
        StateHasChanged();
    }

    private async Task NextStep()
    {
        if (AlgorithmSteps == null || currentStepIndex >= AlgorithmSteps.Count - 1)
        {
            return;
        }

        currentStepIndex++;

        // Make sure highlighting is updated in the UI
        await throttledUpdater.ThrottleAsync();
        StateHasChanged(); // Added explicit UI update
    }

    private async Task PreviousStep()
    {
        if (AlgorithmSteps == null || currentStepIndex <= 0)
        {
            return;
        }

        currentStepIndex--;

        // Make sure highlighting is updated in the UI
        await throttledUpdater.ThrottleAsync();
        StateHasChanged(); // Added explicit UI update
    }

    private async Task GoToStep(int stepIndex)
    {
        if (AlgorithmSteps == null || stepIndex < 0 || stepIndex >= AlgorithmSteps.Count)
        {
            return;
        }

        currentStepIndex = stepIndex;

        // Make sure highlighting is updated in the UI
        await throttledUpdater.ThrottleAsync();
        StateHasChanged(); // Added explicit UI update
    }

    private RenderFragment DrawTreeNodes(TreeNode node) => builder =>
    {
        if (node == null)
            return;

        // Determine node style with clearer highlighting
        string nodeClass = "tree-node";
        if (node.IsActive)
            nodeClass += " active-node";
        if (node.IsHighlighted)
            nodeClass += " highlighted-node";
        if (node.IsResult)
            nodeClass += " result-node";

        // Draw the node
        builder.OpenElement(0, "g");
        builder.AddAttribute(1, "class", nodeClass);
        builder.AddAttribute(2, "transform", $"translate({node.X}, {node.Y})");

        // Node circle with increased size for better visibility
        builder.OpenElement(3, "circle");
        builder.AddAttribute(4, "r", "0.8"); // Slightly larger
        builder.CloseElement();

        // Node value text with better styling
        builder.OpenElement(5, "text");
        builder.AddAttribute(6, "dy", "0.35");
        builder.AddAttribute(7, "text-anchor", "middle");
        builder.AddAttribute(8, "font-size", "0.6"); // Slightly larger
        builder.AddAttribute(9, "font-weight", "bold");
        builder.AddContent(10, node.Value.ToString());
        builder.CloseElement();

        builder.CloseElement();

        // Recursively draw children
        if (node.Left != null)
            builder.AddContent(11, DrawTreeNodes(node.Left));
        if (node.Right != null)
            builder.AddContent(12, DrawTreeNodes(node.Right));
    };

    private RenderFragment DrawTreeEdges(TreeNode node) => builder =>
    {
        if (node == null)
            return;

        // Draw edges to children with better styling
        if (node.Left != null)
        {
            builder.OpenElement(0, "line");
            builder.AddAttribute(1, "x1", node.X.ToString());
            builder.AddAttribute(2, "y1", (node.Y + 0.8).ToString()); // Adjusted for larger node radius
            builder.AddAttribute(3, "x2", node.Left.X.ToString());
            builder.AddAttribute(4, "y2", (node.Left.Y - 0.8).ToString()); // Adjusted for larger node radius
            builder.AddAttribute(5, "class", GetEdgeClass(node, node.Left));
            builder.AddAttribute(6, "stroke-width", "0.15");
            builder.CloseElement();

            // Recursively draw edges for left child
            builder.AddContent(7, DrawTreeEdges(node.Left));
        }

        if (node.Right != null)
        {
            builder.OpenElement(8, "line");
            builder.AddAttribute(9, "x1", node.X.ToString());
            builder.AddAttribute(10, "y1", (node.Y + 0.8).ToString());
            builder.AddAttribute(11, "x2", node.Right.X.ToString());
            builder.AddAttribute(12, "y2", (node.Right.Y - 0.8).ToString());
            builder.AddAttribute(13, "class", GetEdgeClass(node, node.Right));
            builder.AddAttribute(14, "stroke-width", "0.15");
            builder.CloseElement();

            // Recursively draw edges for right child
            builder.AddContent(15, DrawTreeEdges(node.Right));
        }
    };

    // Helper method to determine edge class based on node states
    private string GetEdgeClass(TreeNode parent, TreeNode child)
    {
        string edgeClass = "tree-edge";

        // If both parent and child are active or highlighted, highlight the edge
        if ((parent.IsActive && child.IsActive) ||
            (parent.IsHighlighted && child.IsHighlighted) ||
            (parent.IsActive && child.IsHighlighted) ||
            (parent.IsHighlighted && child.IsActive))
        {
            edgeClass += " highlighted-edge";
        }

        // If either node is a result node, highlight as result
        if (parent.IsResult && child.IsResult)
        {
            edgeClass += " result-edge";
        }

        return edgeClass;
    }

    /// <summary>
    /// Improved algorithm to calculate node positions to prevent overlapping
    /// </summary>
    private void CalculateNodePositionsImproved(TreeNode root)
    {
        if (root == null)
            return;

        // Step 1: Analyze the tree to get its structure
        int maxDepth = GetTreeHeight(root);
        int totalNodes = CountNodes(root);

        // Step 2: Calculate initial positions using level-order traversal
        Dictionary<int, List<TreeNode>> nodesByLevel = new Dictionary<int, List<TreeNode>>();
        PopulateNodesByLevel(root, 0, nodesByLevel);

        // Step 3: Assign X coordinates to prevent overlaps
        AssignXCoordinates(root, nodesByLevel, maxDepth);

        // Step 4: Assign Y coordinates based on level
        AssignYCoordinates(nodesByLevel);

        // Step 5: Apply horizontal adjustment to ensure nodes don't overlap
        AdjustHorizontalSpacing(nodesByLevel, maxDepth);
    }

    private int GetTreeHeight(TreeNode node)
    {
        if (node == null)
            return 0;

        int leftHeight = GetTreeHeight(node.Left);
        int rightHeight = GetTreeHeight(node.Right);

        return Math.Max(leftHeight, rightHeight) + 1;
    }

    private int CountNodes(TreeNode node)
    {
        if (node == null)
            return 0;

        return 1 + CountNodes(node.Left) + CountNodes(node.Right);
    }

    private void PopulateNodesByLevel(TreeNode node, int level, Dictionary<int, List<TreeNode>> nodesByLevel)
    {
        if (node == null)
            return;

        if (!nodesByLevel.ContainsKey(level))
        {
            nodesByLevel[level] = new List<TreeNode>();
        }

        nodesByLevel[level].Add(node);

        PopulateNodesByLevel(node.Left, level + 1, nodesByLevel);
        PopulateNodesByLevel(node.Right, level + 1, nodesByLevel);
    }

    private void AssignXCoordinates(TreeNode root, Dictionary<int, List<TreeNode>> nodesByLevel, int maxDepth)
    {
        // Start with assigning the root node at x=0
        root.X = 0;

        // Process each level
        for (int level = 0; level < nodesByLevel.Count; level++)
        {
            // Sort nodes within each level by their parent's X coordinate
            var nodesAtLevel = nodesByLevel[level];

            if (level > 0) // Skip root level
            {
                // Sort based on parent's X-coordinate and whether the node is a left or right child
                nodesAtLevel = nodesAtLevel.OrderBy(n => {
                    var parent = FindParentNode(root, n.Value);

                    if (parent == null)
                        return 0;

                    // Left children should be placed to the left of their parent
                    if (parent.Left != null && parent.Left.Value == n.Value)
                        return parent.X - 1;

                    // Right children should be placed to the right of their parent
                    return parent.X + 1;
                }).ToList();

                // Update the dictionary with the sorted list
                nodesByLevel[level] = nodesAtLevel;

                // Assign x-coordinates based on parent's X and sibling position
                foreach (var node in nodesAtLevel)
                {
                    var parent = FindParentNode(root, node.Value);

                    if (parent != null)
                    {
                        // Calculate spacing based on level - deeper levels need less spacing
                        double spacingFactor = Math.Max(3.0 / (level + 1), 0.5);

                        if (parent.Left != null && parent.Left.Value == node.Value)
                        {
                            // Left child
                            node.X = parent.X - spacingFactor * (maxDepth - level);
                        }
                        else
                        {
                            // Right child
                            node.X = parent.X + spacingFactor * (maxDepth - level);
                        }
                    }
                }
            }
        }
    }

    private void AssignYCoordinates(Dictionary<int, List<TreeNode>> nodesByLevel)
    {
        // Assign Y coordinates based on level
        foreach (var level in nodesByLevel.Keys)
        {
            double yPos = level * 2.0; // Increased vertical spacing between levels

            foreach (var node in nodesByLevel[level])
            {
                node.Y = yPos;
            }
        }
    }

    private void AdjustHorizontalSpacing(Dictionary<int, List<TreeNode>> nodesByLevel, int maxDepth)
    {
        const double MinNodeDistance = 1.5; // Minimum horizontal distance between nodes

        // Process each level to ensure minimum distance between siblings
        for (int level = 0; level < nodesByLevel.Count; level++)
        {
            var nodesAtLevel = nodesByLevel[level].OrderBy(n => n.X).ToList();

            // Skip if there's only one node at this level
            if (nodesAtLevel.Count <= 1)
                continue;

            // Ensure minimum distance between adjacent nodes
            for (int i = 1; i < nodesAtLevel.Count; i++)
            {
                var leftNode = nodesAtLevel[i - 1];
                var rightNode = nodesAtLevel[i];

                double currentDistance = rightNode.X - leftNode.X;

                if (currentDistance < MinNodeDistance)
                {
                    double adjustment = (MinNodeDistance - currentDistance) / 2;

                    // Move left node left and right node right
                    leftNode.X -= adjustment;
                    rightNode.X += adjustment;
                }
            }
        }
    }

    /// <summary>
    /// Finds the parent of a node with the specified value
    /// </summary>
    private TreeNode FindParentNode(TreeNode root, int childValue)
    {
        if (root == null)
            return null;

        // Check if this node is the parent
        if ((root.Left != null && root.Left.Value == childValue) ||
            (root.Right != null && root.Right.Value == childValue))
            return root;

        // Search in left subtree
        TreeNode leftResult = FindParentNode(root.Left, childValue);
        if (leftResult != null)
            return leftResult;

        // Search in right subtree
        return FindParentNode(root.Right, childValue);
    }

    /// <summary>
    /// Finds a node with the specified value in the tree
    /// </summary>
    private TreeNode FindNode(TreeNode root, int value)
    {
        if (root == null)
            return null;

        if (root.Value == value)
            return root;

        // Try to find in left subtree
        TreeNode leftResult = FindNode(root.Left, value);
        if (leftResult != null)
            return leftResult;

        // Try to find in right subtree
        return FindNode(root.Right, value);
    }
}

<style>
    .tree-container {
        display: flex;
        height: 100%;
        width: 100%;
    }

    .tree-controls {
        flex: 0 0 300px;
        padding: 15px;
        background-color: white;
        border-right: 1px solid #e0e0e0;
        overflow-y: auto;
    }

    .tree-visualization {
        flex: 1;
        position: relative;
        overflow: hidden;
        padding: 15px;
        background-color: white;
    }

    .control-section {
        margin-bottom: 20px;
    }

    .control-section h3 {
        font-size: 1.1rem;
        font-weight: 500;
        margin-bottom: 15px;
        color: #3f51b5;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 8px;
    }

    .algorithm-info-card, .stats-card {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        border-left: 4px solid #3f51b5;
    }

    .step-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        margin-top: 10px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    .step-counter {
        font-weight: 500;
        color: #212121;
        padding: 0 8px;
    }

    .step-description {
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        margin-top: 10px;
        border-left: 4px solid #3f51b5;
        display: flex;
        align-items: flex-start;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    .step-description p {
        margin: 0;
    }

    .auto-play-control, .speed-control {
        display: flex;
        align-items: center;
    }

    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
    }

    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3f51b5;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 1rem;
    }

    .validation-message {
        color: #f44336;
        font-size: 0.9rem;
        margin-top: 0.25rem;
    }

    .auto-play-control, .speed-control {
        display: flex;
        align-items: center;
    }

    .tree-svg {
        width: 100%;
        height: 100%;
        max-height: 700px; /* Increased height for deeper trees */
    }

    /* Improved node styling */
    .tree-node circle {
        fill: #fff;
        stroke: #4CAF50;
        stroke-width: 0.1;
        transition: all 0.3s ease;
    }

    .tree-node text {
        fill: #333;
        transition: all 0.3s ease;
    }

    .tree-edge {
        stroke: #90A4AE;
        stroke-linecap: round;
        transition: all 0.3s ease;
    }

    /* Enhanced highlighting for active node */
    .active-node circle {
        fill: #FFC107;
        stroke: #FF9800;
        stroke-width: 0.2;
        filter: drop-shadow(0 0 0.2px rgba(255, 152, 0, 0.7));
        animation: pulse 1s infinite;
    }

    .active-node text {
        fill: #d32f2f;
        font-weight: bold;
    }

    /* Enhanced highlighting for highlighted node */
    .highlighted-node circle {
        stroke: #2196F3;
        stroke-width: 0.2;
        filter: drop-shadow(0 0 0.2px rgba(33, 150, 243, 0.7));
    }

    .highlighted-node text {
        fill: #0d47a1;
        font-weight: bold;
    }

    /* Enhanced highlighting for result node */
    .result-node circle {
        fill: #E1F5FE;
        stroke: #03A9F4;
        stroke-width: 0.2;
        filter: drop-shadow(0 0 0.2px rgba(3, 169, 244, 0.7));
    }

    .result-node text {
        fill: #01579b;
        font-weight: bold;
    }

    /* Edge highlighting styles */
    .highlighted-edge {
        stroke: #2196F3;
        stroke-width: 0.2;
        filter: drop-shadow(0 0 0.1px rgba(33, 150, 243, 0.7));
    }

    .result-edge {
        stroke: #03A9F4;
        stroke-width: 0.2;
        filter: drop-shadow(0 0 0.1px rgba(3, 169, 244, 0.7));
    }

    .empty-tree-message {
        font-size: 1rem;
        fill: #9E9E9E;
    }

    @@keyframes pulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.1);
        }
        100% {
            transform: scale(1);
        }
    }

    @@keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }

    @@media (max-width: 768px) {
        .tree-container {
            flex-direction: column;
        }

        .tree-controls {
            flex: 0 0 auto;
            max-height: 300px;
        }

        .step-controls {
            flex-direction: column;
            align-items: flex-start;
        }

        .speed-control {
            margin-left: 0;
            margin-top: 10px;
            width: 100%;
        }
    }
</style>